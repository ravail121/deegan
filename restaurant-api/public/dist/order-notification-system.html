<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Notification System</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', monospace;
            margin: 0;
            padding: 20px;
            background-color: #000;
            color: #0f0;
        }
        
        .log {
            font-size: 14px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-info {
            color: #0f0;
        }
        
        .log-success {
            color: #ff0;
        }
        
        .log-error {
            color: #f00;
        }
        
        .test-button {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Poppins', monospace;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            z-index: 1000;
        }
        
        .test-button:hover {
            background: #0a0;
        }
    </style>
</head>
<body>
    <button class="test-button" onclick="testSound()">üîä TEST SOUND</button>
    
    <div class="log" id="log">
        <div class="log-entry log-info">Order Notification System Started...</div>
        <div class="log-entry log-success">‚ö†Ô∏è IMPORTANT: Click anywhere on this page to enable audio notifications</div>
        <div class="log-entry log-info">Click the TEST SOUND button to test audio</div>
        <div class="log-entry log-info">Without clicking first, new orders will only show system beep</div>
    </div>

    <script>
        /**
         * Standalone Order Notification System
         * 
         * This file runs independently and checks for new e-menu orders every 10 seconds.
         * When new orders are detected, it plays a notification sound.
         * 
         * Usage: Open this file in your browser for the restaurant system dashboard
         */

        class OrderNotificationSystem {
            constructor() {
                this.apiUrl = '/api/orders'; // Adjust this URL as needed
                this.checkInterval = 10000; // 10 seconds (configurable)
                this.lastOrderId = null;
                this.isRunning = false;
                this.intervalId = null;
                this.audioContext = null;
                this.audioInitialized = false;
                this.consecutiveErrors = 0; // Track consecutive errors
                this.lastErrorType = null; // Track error type
                this.maxConsecutiveErrors = 3; // Alert after 3 consecutive errors
                
                // Initialize the system
                this.init();
            }

            /**
             * Initialize the notification system
             */
            init() {
                console.log('üîî Order Notification System initialized');
                
                // Request notification permission
                this.requestNotificationPermission();
                
                // Add click handler to initialize audio on first user interaction
                this.addAudioInitHandler();
                
                // Get the last order ID on startup
                this.getLastOrderId().then(() => {
                    this.startMonitoring();
                }).catch(error => {
                    console.error('‚ùå Failed to initialize notification system:', error);
                });
            }
            
            /**
             * Request notification permission
             */
            requestNotificationPermission() {
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            console.log('‚úÖ Desktop notifications enabled');
                        }
                    });
                }
            }

            /**
             * Add click handler to initialize audio on first user interaction
             */
            addAudioInitHandler() {
                const initAudio = () => {
                    if (!this.audioInitialized) {
                        this.audioInitialized = true;
                        this.initAudioContext();
                        // Remove the event listeners after first interaction
                        document.removeEventListener('click', initAudio);
                        document.removeEventListener('keydown', initAudio);
                        document.removeEventListener('touchstart', initAudio);
                    }
                };

                // Add event listeners for various user interactions
                document.addEventListener('click', initAudio);
                document.addEventListener('keydown', initAudio);
                document.addEventListener('touchstart', initAudio);
            }

            /**
             * Get the last order ID to establish baseline
             */
            async getLastOrderId() {
                try {
                    const response = await this.makeApiCall('GET', this.apiUrl + '/latest');
                    if (response.success && response.data) {
                        this.lastOrderId = response.data.orderID;
                    } else {
                        // If no orders exist, start from 0
                        this.lastOrderId = 0;
                    }
                } catch (error) {
                    console.error('‚ùå Error getting last order ID:', error);
                    this.lastOrderId = 0;
                }
            }

            /**
             * Start monitoring for new orders
             */
            startMonitoring() {
                if (this.isRunning) {
                    return;
                }

                this.isRunning = true;
                console.log('üöÄ Order monitoring started');
                
                // Check immediately
                this.checkForNewOrders();
                
                // Then check at specified interval
                this.intervalId = setInterval(() => {
                    this.checkForNewOrders();
                }, this.checkInterval);
            }

            /**
             * Stop monitoring for new orders
             */
            stopMonitoring() {
                if (!this.isRunning) {
                    return;
                }

                this.isRunning = false;
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
                console.log('‚èπÔ∏è Order monitoring stopped');
            }

            /**
             * Check for new orders
             */
            async checkForNewOrders() {
                try {
                    // Get orders newer than our last known order
                    const response = await this.makeApiCall('GET', `${this.apiUrl}/newer/${this.lastOrderId}`);
                    
                    if (response.success && response.data && response.data.length > 0) {
                        console.log(`üéâ NEW ORDERS DETECTED! Found ${response.data.length} new order(s)!`);
                        
                        // Reset error counter on success
                        this.consecutiveErrors = 0;
                        this.lastErrorType = null;
                        
                        // Process each new order
                        for (const order of response.data) {
                            this.handleNewOrder(order);
                        }
                        
                        // Update last order ID to the newest one
                        const newestOrder = response.data[response.data.length - 1];
                        this.lastOrderId = newestOrder.orderID;
                        
                    } else {
                        // No new orders found - this is a success state, not an error
                        // Silent - no logging needed for successful "no new orders" check
                        
                        // Reset error counter on successful check (even with no new orders)
                        this.consecutiveErrors = 0;
                        this.lastErrorType = null;
                    }
                    
                } catch (error) {
                    this.handleApiError(error);
                }
            }
            
            /**
             * Handle API errors with better feedback
             */
            handleApiError(error) {
                this.consecutiveErrors++;
                
                // Check for authentication error (401)
                if (error.message && error.message.includes('401')) {
                    if (this.lastErrorType !== 'auth') {
                        console.error('‚ö†Ô∏è Authentication Error: The notification system needs proper API access');
                        console.error('‚ÑπÔ∏è Please ensure the order API endpoints are accessible');
                        this.lastErrorType = 'auth';
                    }
                }
                // Check for network/connection errors
                else if (error.message && (error.message.includes('Failed to fetch') || error.message.includes('NetworkError'))) {
                    if (this.lastErrorType !== 'network') {
                        console.error('‚ö†Ô∏è Network Error: Cannot connect to the server');
                        console.error('‚ÑπÔ∏è Please check your internet connection and server status');
                        this.lastErrorType = 'network';
                    }
                }
                // Other errors
                else {
                    if (this.consecutiveErrors === 1) {
                        console.error('‚ùå Error checking for new orders:', error.message || error);
                    }
                }
                
                // Alert if too many consecutive errors
                if (this.consecutiveErrors === this.maxConsecutiveErrors) {
                    console.error(`üö® ALERT: ${this.consecutiveErrors} consecutive errors detected! System may not be working properly.`);
                }
            }

            /**
             * Handle a new order notification
             */
            handleNewOrder(order) {
                // Play notification sound
                this.playNotificationSound();
                
                // Show desktop notification
                this.showDesktopNotification(order);
            }
            
            /**
             * Show desktop notification
             */
            showDesktopNotification(order) {
                if ('Notification' in window && Notification.permission === 'granted') {
                    const notification = new Notification('üîî New Order Received!', {
                        body: `Order #${order.orderID}\nTable: ${order.tableName}\nAmount: $${parseFloat(order.orderAmount).toFixed(2)}`,
                        icon: '/logo.png',
                        badge: '/icon-192.png',
                        tag: `order-${order.orderID}`,
                        requireInteraction: true,
                        vibrate: [200, 100, 200]
                    });
                    
                    notification.onclick = () => {
                        window.focus();
                        notification.close();
                    };
                }
            }

            /**
             * Play notification sound
             */
            playNotificationSound() {
                try {
                    // Method 1: Try Web Audio API with user interaction
                    if (this.audioContext && this.audioContext.state === 'running') {
                        this.playWebAudioBeep();
                        return;
                    }
                    
                    // Method 2: Use HTML5 Audio with data URI (more reliable)
                    this.playHTML5Beep();
                    
                } catch (error) {
                    console.error('‚ùå Error playing notification sound:', error);
                    // Method 3: Fallback to system beep
                    this.playSystemBeep();
                }
            }

            /**
             * Play beep using Web Audio API
             */
            playWebAudioBeep() {
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Configure the beep
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    // Set volume (increased from 0.3 to 0.8)
                    gainNode.gain.setValueAtTime(0.8, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    
                    // Play the beep
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                    
                } catch (error) {
                    this.playHTML5Beep();
                }
            }

            /**
             * Play beep using HTML5 Audio (most reliable)
             */
            playHTML5Beep() {
                try {
                    // Check if audio is allowed (user has interacted)
                    if (!this.audioInitialized) {
                        this.playSystemBeep();
                        return;
                    }
                    
                    // Create a simple beep sound using data URI (fixed)
                    const beepData = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT';
                    
                    const audio = new Audio(beepData);
                    audio.volume = 1.0; // Increased from 0.7 to 1.0 (maximum)
                    audio.play().catch(() => {
                        // Try alternative beep method
                        this.playAlternativeBeep();
                    });
                    
                } catch (error) {
                    this.playAlternativeBeep();
                }
            }

            /**
             * Alternative beep method using Web Audio API directly
             */
            playAlternativeBeep() {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Configure the beep
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    // Set volume (increased from 0.5 to 0.9)
                    gainNode.gain.setValueAtTime(0.9, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    
                    // Play the beep
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    
                } catch (error) {
                    this.playSystemBeep();
                }
            }

            /**
             * Fallback system beep
             */
            playSystemBeep() {
                try {
                    console.log('\x07'); // ASCII bell character
                } catch (error) {
                    // Silent fallback
                }
            }


            /**
             * Initialize audio context (call this on first user interaction)
             */
            initAudioContext() {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå Audio context initialization failed:', error);
                    return false;
                }
            }




            /**
             * Make API call with error handling
             */
            async makeApiCall(method, url, data = null) {
                try {
                    // Add cache-busting parameter to prevent browser caching
                    const separator = url.includes('?') ? '&' : '?';
                    const cacheBuster = `${separator}_t=${Date.now()}&_r=${Math.random()}`;
                    const urlWithCacheBuster = url + cacheBuster;

                    const options = {
                        method: method,
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache'
                        }
                    };

                    if (data) {
                        options.body = JSON.stringify(data);
                    }

                    const response = await fetch(urlWithCacheBuster, options);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    return await response.json();
                    
                } catch (error) {
                    console.error('‚ùå API call failed:', error);
                    throw error;
                }
            }

            /**
             * Get system status
             */
            getStatus() {
                return {
                    isRunning: this.isRunning,
                    lastOrderId: this.lastOrderId,
                    checkInterval: this.checkInterval,
                    apiUrl: this.apiUrl
                };
            }

            /**
             * Update configuration
             */
            updateConfig(config) {
                if (config.checkInterval) {
                    const oldInterval = this.checkInterval;
                    this.checkInterval = config.checkInterval;
                    console.log(`‚öôÔ∏è Check interval updated from ${oldInterval/1000}s to ${this.checkInterval/1000}s`);
                }
                if (config.apiUrl) {
                    this.apiUrl = config.apiUrl;
                    console.log(`‚öôÔ∏è API URL updated to: ${this.apiUrl}`);
                }
                
                // Restart monitoring if it's running
                if (this.isRunning) {
                    this.stopMonitoring();
                    this.startMonitoring();
                }
            }
            
            /**
             * Set check interval in seconds
             */
            setCheckInterval(seconds) {
                if (seconds < 5) {
                    console.error('‚ö†Ô∏è Minimum check interval is 5 seconds');
                    return;
                }
                if (seconds > 300) {
                    console.error('‚ö†Ô∏è Maximum check interval is 300 seconds (5 minutes)');
                    return;
                }
                this.updateConfig({ checkInterval: seconds * 1000 });
            }
        }

        // Auto-initialize when script loads
        let orderNotificationSystem;

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                orderNotificationSystem = new OrderNotificationSystem();
            });
        } else {
            orderNotificationSystem = new OrderNotificationSystem();
        }

        // Expose to global scope for manual control
        window.OrderNotificationSystem = OrderNotificationSystem;
        window.orderNotificationSystem = orderNotificationSystem;
        
        // Simple beep function that works immediately
        window.playBeep = function() {
            try {
                // Create audio context if it doesn't exist
                if (!window.audioContext) {
                    window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Resume if suspended
                if (window.audioContext.state === 'suspended') {
                    window.audioContext.resume();
                }
                
                // Create oscillator
                const oscillator = window.audioContext.createOscillator();
                const gainNode = window.audioContext.createGain();
                
                // Connect nodes
                oscillator.connect(gainNode);
                gainNode.connect(window.audioContext.destination);
                
                // Configure beep
                oscillator.frequency.setValueAtTime(800, window.audioContext.currentTime);
                oscillator.type = 'sine';
                
                // Set volume and fade out
                gainNode.gain.setValueAtTime(0.5, window.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.4);
                
                // Play beep
                oscillator.start(window.audioContext.currentTime);
                oscillator.stop(window.audioContext.currentTime + 0.4);
                
                return true;
            } catch (error) {
                console.error('Beep failed:', error);
                return false;
            }
        };

        // Test sound function
        window.testSound = function() {
            addLogEntry('üîä Testing sound...', 'log-info');
            
            // Try simple beep first
            if (window.playBeep()) {
                addLogEntry('üîä Test sound played successfully!', 'log-success');
                return;
            }
            
            // Fallback: try HTML5 Audio
            try {
                const audio = new Audio();
                audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT';
                audio.volume = 0.7;
                audio.play().then(() => {
                    addLogEntry('üîä Fallback test sound played!', 'log-success');
                }).catch((err) => {
                    addLogEntry('‚ùå All sound methods failed: ' + err.message, 'log-error');
                });
            } catch (fallbackError) {
                addLogEntry('‚ùå All sound methods failed: ' + fallbackError.message, 'log-error');
            }
        };

        // Override console.log to show in our log
        const originalLog = console.log;
        const originalError = console.error;
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            addLogEntry(args.join(' '), 'log-info');
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            addLogEntry(args.join(' '), 'log-error');
        };
        
        function addLogEntry(message, type = 'log-info') {
            const log = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        // Wait for notification system to load, then start monitoring
        function waitForSystem() {
            if (window.orderNotificationSystem) {
                addLogEntry('Notification system loaded', 'log-success');
                
                // Override the handleNewOrder method to show in log and play beep
                const originalHandle = window.orderNotificationSystem.handleNewOrder;
                window.orderNotificationSystem.handleNewOrder = function(order) {
                    addLogEntry(`üîî NEW ORDER! #${order.orderID} - Table: ${order.tableName} - Amount: $${order.orderAmount}`, 'log-success');
                    
                    // Try to play beep sound
                    if (window.playBeep()) {
                        addLogEntry('üîä Order notification sound played!', 'log-success');
                    } else {
                        // If audio context not initialized, try to initialize it
                        if (!window.audioContext || window.audioContext.state === 'suspended') {
                            try {
                                if (!window.audioContext) {
                                    window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                                }
                                window.audioContext.resume();
                                
                                // Try beep again
                                if (window.playBeep()) {
                                    addLogEntry('üîä Order notification sound played!', 'log-success');
                                } else {
                                    addLogEntry('üîá Sound failed, using system beep', 'log-info');
                                    console.log('\x07'); // ASCII bell
                                }
                            } catch (error) {
                                addLogEntry('üîá Audio initialization failed, using system beep', 'log-info');
                                console.log('\x07'); // ASCII bell
                            }
                        } else {
                            addLogEntry('üîá Sound failed, using system beep', 'log-info');
                            console.log('\x07'); // ASCII bell
                        }
                    }
                    
                    return originalHandle.call(this, order);
                };
                
                // Start monitoring automatically
                setTimeout(() => {
                    window.orderNotificationSystem.startMonitoring();
                    addLogEntry('Auto-started monitoring for new orders...', 'log-info');
                }, 1000);
                
            } else {
                setTimeout(waitForSystem, 100);
            }
        }
        
        // Start waiting for the system
        waitForSystem();
        
        // Initialize audio context on any user interaction
        function initializeAudioOnInteraction() {
            if (window.orderNotificationSystem && !window.orderNotificationSystem.audioInitialized) {
                window.orderNotificationSystem.initAudioContext();
                addLogEntry('Audio initialized - sound notifications enabled!', 'log-success');
                
                // Remove event listeners after initialization
                document.removeEventListener('click', initializeAudioOnInteraction);
                document.removeEventListener('keydown', initializeAudioOnInteraction);
                document.removeEventListener('touchstart', initializeAudioOnInteraction);
            }
        }

        // Add multiple event listeners for audio initialization
        document.addEventListener('click', initializeAudioOnInteraction);
        document.addEventListener('keydown', initializeAudioOnInteraction);
        document.addEventListener('touchstart', initializeAudioOnInteraction);

    </script>
</body>
</html>
